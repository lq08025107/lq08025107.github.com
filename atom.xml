<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[刘强的博客]]></title>
  <subtitle><![CDATA[Watch and Learn]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://lq08025107.github.io/"/>
  <updated>2016-11-10T02:59:26.264Z</updated>
  <id>http://lq08025107.github.io/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[docker杂谈]]></title>
    <link href="http://lq08025107.github.io/2016/11/10/docker%E6%9D%82%E8%B0%88/"/>
    <id>http://lq08025107.github.io/2016/11/10/docker杂谈/</id>
    <published>2016-11-10T02:58:47.000Z</published>
    <updated>2016-11-10T02:59:26.264Z</updated>
    <content type="html"><![CDATA[<h3 id="u4EC0_u4E48_u662Fdocker"><a href="#u4EC0_u4E48_u662Fdocker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>最近工作需要，项目需要做一些底层虚拟化的东西，加之之前“师傅”说过有空弄弄docker，就又拾起来这东西。容器技术是虚拟化的一种，一个容器就可以理解为一个虚拟机。docker就是最火的一种容器技术，容器里边你可以干你任何想干的事情。为什么要弄出容器这么个概念呢，直接vmware workstation里边跑不行吗？答案当然是可以的，但是docker比虚拟机省资源呀，而且适合开发部署时候一条龙服务，诸多优点网上很多，以上就是我对docker以及优点的通俗解释。<br><a id="more"></a></p>
<h3 id="u4E00_u5B9A_u8981_u6253_u597D_u57FA_u7840"><a href="#u4E00_u5B9A_u8981_u6253_u597D_u57FA_u7840" class="headerlink" title="一定要打好基础"></a>一定要打好基础</h3><p>基础真的非常重要！！！遇到一个新东西，首先是概念，然后是基础，然后是进阶，最后才是折腾出你想要的东西。这个规律不可违背，否则就会走弯路。具体docker来说，镜像和容器这两个概念是docker一切的基础。</p>
<p>废话两句，宿主OS最好选用linux，我用的ubuntu 14.04，或者win10，总感觉Windows下ToolBox不那么好用。</p>
<p>docker Daemon：当你在宿主机安装了docker之后，就有了一个Daemon，我的理解，docker daemon就像一个管理者，替你管理着其中的容器。</p>
<p>docker Image：docker镜像涉及layer的概念，可以想象一下photoshop的层的概念，每一层都有不同的文件，最后的镜像就有由一堆文件组成的，所以当你docker pull的时候，总是看见一个镜像由好多层组成，当你pull下来或者通过dockerfile build出镜像，他就是个固定的东西了。docker images可以查看当前daemon中的镜像。这里有关于Image的详细解释。<a href="http://www.open-open.com/lib/view/open1446695630904.html" target="_blank" rel="external">Image</a></p>
<p>docker container：要着重理解image和container的区别，container是通过image构建出来的，container有运行态和非运行态，docker ps和docker ps -a就可以分别查看之。每一个docker run都会产生一个容器，在此期间你对该容器所做的修改都将存储在了Container中，如果下次你还想继续使用，那么就应该docker start containerID，而不是run了，这点很重要。</p>
<p>docker基本操作如下图所示：</p>
<p><img src="http://7xr558.com1.z0.glb.clouddn.com/docker.png" alt="docker基础操作"></p>
<p>单机docker的操作基本如上图所示，上图右边三个工具，docker machine、docker compose、 docker swarm,号称docker三大利器，其作用分别如下：</p>
<p>Machine： 解决的是操作系统异构安装Docker困难的问题，没有Machine的时候，CentOS是一种，Ubuntu又是一种，AWS又是一种。有了Machine，所有的系统都是一样的安装方式。</p>
<p>Swarm： 我们有了Machine就意味着有了docker环境，但是那是单机的，而通常我们的应用都是集群的。这正是Swarm要做的事情，给你提供docker集群环境和调度策略等。</p>
<p>Compose: 有了环境，我们下一步要做什么？部署应用啊。然后我们需要docker run image1、docker run image2…一次一次不厌其烦的重复这些操作，每次都写大量的命令参数。Compose简化了这个流程，只需要把这些内容固化到docker-compose.yml中。</p>
<p>个人感觉docker在集群方面不很方便，集群最后落脚在网络通信，所以docker集群部署不很方便的最主要原因就是网络问题，针对网络问题，也有各种花式解决方案，譬如linux下的工具pipeline、weave等等，swarm用官方的话来说是一种原生集群解决方案。</p>
<p>接下来放一张神图，网上找的docker eco的一张图，可以大体了解这个生态圈。<br><img src="http://7xr558.com1.z0.glb.clouddn.com/docker%20eco.jpg" alt="docker eco"></p>
<h3 id="docker_u4E2D_u8FD0_u884C_u5BB9_u5668"><a href="#docker_u4E2D_u8FD0_u884C_u5BB9_u5668" class="headerlink" title="docker中运行容器"></a>docker中运行容器</h3><p>根据自己的需求运行各种容器，两种构建方法，一种是通过docker file来构建，一种是直接从docker hub上pull，一般你想到的hub上都有，譬如什么storm、kafka，这两个我都尝试构建了一下，用了docker search中star比较高的ches/kafka等等，感谢作者辛勤奉献。</p>
<p>docker ui 是一个不错的项目，本身运行在一个容器中，监控一个主机的deamon，适合新手使用，给你最直观的理解。<br>shipyard则可以管理集群，但是部署比较复杂，工具类的东西大家可以按照自己的需求来选择。</p>
<p>###总结<br>七七八八写了一些，没有涉及具体的操作命令，那些都可以从官方doc中找到，只是写了一些个人理解，但是自己觉得也写的很屎，究其原因还是自己水平不够，所以这篇博客就到这儿，再研究研究有了新的想法再写。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4EC0_u4E48_u662Fdocker"><a href="#u4EC0_u4E48_u662Fdocker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>最近工作需要，项目需要做一些底层虚拟化的东西，加之之前“师傅”说过有空弄弄docker，就又拾起来这东西。容器技术是虚拟化的一种，一个容器就可以理解为一个虚拟机。docker就是最火的一种容器技术，容器里边你可以干你任何想干的事情。为什么要弄出容器这么个概念呢，直接vmware workstation里边跑不行吗？答案当然是可以的，但是docker比虚拟机省资源呀，而且适合开发部署时候一条龙服务，诸多优点网上很多，以上就是我对docker以及优点的通俗解释。<br>]]>
    
    </summary>
    
      <category term="docker" scheme="http://lq08025107.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java代理]]></title>
    <link href="http://lq08025107.github.io/2016/07/17/Java%E4%BB%A3%E7%90%86/"/>
    <id>http://lq08025107.github.io/2016/07/17/Java代理/</id>
    <published>2016-07-17T08:35:48.000Z</published>
    <updated>2016-07-17T08:52:16.085Z</updated>
    <content type="html"><![CDATA[<h3 id="u5199_u5728_u6700_u524D_u9762"><a href="#u5199_u5728_u6700_u524D_u9762" class="headerlink" title="写在最前面"></a>写在最前面</h3><p>距离上一次写博客不知道经过多久了，有很多原因吧，家里的事占用了一部分心情，然后就是工行的破事，没完没了，最近终于脱身来做一些自己不反感的事情了，身体上累一点也觉得不那么难受</p>
<h3 id="u4E3B_u9898_uFF1A_u4EE3_u7406"><a href="#u4E3B_u9898_uFF1A_u4EE3_u7406" class="headerlink" title="主题：代理"></a>主题：代理</h3><p>代理这个词在生活中出现的频率可谓不低，上网挂代理、微商代理，其实细想想和编程中的代理是一回事，就拿微商代理来说，真正的产品供货商就是你程序中的业务实体（类、接口），那些成天发朋友圈的讨厌的人就是代理，你是客户端，客户端请求时不与服务提供商直接打交道，而是通过代理。但有一点不同的是，微商代理很讨厌，而编程中的代理很讨人喜欢。当然他们都有共同点，那就是<strong>代理可以帮你做一些额外的事情</strong>。<br>代理模式会隐藏真实的业务主体，从而达到一种封装的效果，这也是面向对象编程的一个基本思想吧。<br><a id="more"></a></p>
<h3 id="u9759_u6001_u4EE3_u7406"><a href="#u9759_u6001_u4EE3_u7406" class="headerlink" title="静态代理"></a>静态代理</h3><p>首先谈一谈静态代理，静态代理是最简单的代理模式。直接上代码：</p>
<p>业务接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBusiness</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earnMoney</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真实业务主体，实现了业务接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span> <span class="keyword">implements</span> <span class="title">IBusiness</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earnMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"股票上涨"</span>);				</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessProxy</span> <span class="keyword">implements</span> <span class="title">IBusiness</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IBusiness ib;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BusinessProxy</span><span class="params">(IBusiness ib)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ib=ib;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earnMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">		buy();</span><br><span class="line">		ib.earnMoney();</span><br><span class="line">		sell();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"低价买进"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"高价卖出"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	IBusiness ib=<span class="keyword">new</span> Business();</span><br><span class="line">	IBusiness ibp=<span class="keyword">new</span> BusinessProxy(ib);</span><br><span class="line">	ibp.earnMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就实现了一个最简单的代理类，实体类只是说股票要上涨，然而你无动于是，还是赚不了钱，所以需要代理类来帮你做一些买入卖出操作，这样你才能完成这个操作。</p>
<h3 id="Java_u52A8_u6001_u4EE3_u7406"><a href="#Java_u52A8_u6001_u4EE3_u7406" class="headerlink" title="Java动态代理"></a>Java动态代理</h3><p>使用静态代理虽然达到了上述目的，但是必须手动创建业务类，这样其实增加了耦合度，所以Java中有了动态代理。动态代理需要引用java中的Proxy类以及InvocationHandler接口。<br>上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMasterBusiness</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earnMoney</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterBusiness</span> <span class="keyword">implements</span> <span class="title">IMasterBusiness</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earnMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"股票上涨"</span>);				</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterBusinessIntercepter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"低价买进"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"高价卖出"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterBusinessHander</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object masterBusinee;</span><br><span class="line">    <span class="comment">//拦截器</span></span><br><span class="line">    <span class="keyword">private</span> MasterBusinessIntercepter intercepter = <span class="keyword">new</span> MasterBusinessIntercepter();</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MasterBusinessHander</span><span class="params">(Object masterBusinee)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.masterBusinee = masterBusinee;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"earnMoney"</span>))&#123;</span><br><span class="line">            intercepter.buy();</span><br><span class="line">            result = method.invoke(masterBusinee, args);</span><br><span class="line">            intercepter.sell();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result = method.invoke(masterBusinee, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个调用器</span></span><br><span class="line">        MasterBusinessHander handler = <span class="keyword">new</span> MasterBusinessHander(<span class="keyword">new</span> MasterBusiness());</span><br><span class="line">        IMasterBusiness target = (IMasterBusiness)Proxy.newProxyInstance(<span class="keyword">new</span> MasterBusiness().getClass().getClassLoader(), <span class="keyword">new</span> MasterBusiness().getClass().getInterfaces(), handler);</span><br><span class="line">        target.earnMoney();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，上述动态代理将sell和buy方法剥离了出来，达到了目的，这也是Java动态代理的标准创建流程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5199_u5728_u6700_u524D_u9762"><a href="#u5199_u5728_u6700_u524D_u9762" class="headerlink" title="写在最前面"></a>写在最前面</h3><p>距离上一次写博客不知道经过多久了，有很多原因吧，家里的事占用了一部分心情，然后就是工行的破事，没完没了，最近终于脱身来做一些自己不反感的事情了，身体上累一点也觉得不那么难受</p>
<h3 id="u4E3B_u9898_uFF1A_u4EE3_u7406"><a href="#u4E3B_u9898_uFF1A_u4EE3_u7406" class="headerlink" title="主题：代理"></a>主题：代理</h3><p>代理这个词在生活中出现的频率可谓不低，上网挂代理、微商代理，其实细想想和编程中的代理是一回事，就拿微商代理来说，真正的产品供货商就是你程序中的业务实体（类、接口），那些成天发朋友圈的讨厌的人就是代理，你是客户端，客户端请求时不与服务提供商直接打交道，而是通过代理。但有一点不同的是，微商代理很讨厌，而编程中的代理很讨人喜欢。当然他们都有共同点，那就是<strong>代理可以帮你做一些额外的事情</strong>。<br>代理模式会隐藏真实的业务主体，从而达到一种封装的效果，这也是面向对象编程的一个基本思想吧。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://lq08025107.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java volatile 关键字]]></title>
    <link href="http://lq08025107.github.io/2016/07/12/Java-volatile-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://lq08025107.github.io/2016/07/12/Java-volatile-关键字/</id>
    <published>2016-07-12T15:30:59.000Z</published>
    <updated>2016-07-12T15:37:34.901Z</updated>
    <content type="html"><![CDATA[<p>看到了一篇特别好的博文，就专门开一贴转载过来，从今天开始慢慢重新开始写博客</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">Java并发编程：volatile关键字解析</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看到了一篇特别好的博文，就专门开一贴转载过来，从今天开始慢慢重新开始写博客</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">J]]>
    </summary>
    
      <category term="Java" scheme="http://lq08025107.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Consul+Consul template+Docker+Registrator+nginx实现动态服务注册和服务发现]]></title>
    <link href="http://lq08025107.github.io/2016/03/26/%E4%BD%BF%E7%94%A8Consul-Consul-template-Docker-Registrator-nginx%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>http://lq08025107.github.io/2016/03/26/使用Consul-Consul-template-Docker-Registrator-nginx实现动态服务注册和服务发现/</id>
    <published>2016-03-26T09:26:12.000Z</published>
    <updated>2016-03-26T09:30:26.291Z</updated>
    <content type="html"><![CDATA[<p><strong>写在最前面</strong>：本文尝试使用Docker、Registrator、Consul、Consul-template和Nginx实现可扩展的、支持服务注册、服务发现的架构。本文不涉及这些软件的具体实现方法，是对其功能进行探索。<br><a id="more"></a></p>
<h1 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h1><p><strong>Docker</strong>，容器(Container)技术近年来为什么会兴起？我的理解是因为整个世界都是网络了，既然有网络应用的消费者，那必须就有网络应用的生产者，容器技术就是生产者为了解脱自己的痛苦而创造的一个东西，背后的思想是创建软件程序可移植的轻量容器。通俗地讲，开发者在开发环境中开发自己的应用，要部署到实际生产线是一件非常复杂的事情，docker的出现，使得开发者一切操作都在docker中进行，把docker搬到生产环境中即可使用，非常方便。<em>软件的出现的目的总是让使用者更加方便</em>，所以学习一下docker还是会给你一种新的启发。</p>
<p><strong>Consul</strong>，Consul是HahsiCorp开发的一个服务发现与配置的项目，Consul实质上以KV形式保存数据，你可以理解Consul就是你的<strong>服务管家</strong>，这个管家不止可以创建Cluster，还有良好的Web界面，值得推荐。这时不得不提到另一个大名鼎鼎的动物园管家，Zookeeper，在公司实际项目中，zk来做服务的发现注册已经有一套方案，本文的方法算是另一条路吧，不存在好坏之分。</p>
<p>Consul-template，他在监控着Consul，当其发现其中的服务项有变化时，更新文件并执行操作。譬如本文中要做的，更新nginx配置文件，并对nginx进行<strong>优雅</strong>地重启。</p>
<p><strong>Registrator</strong>，原名叫Docksul，看名字就知道，他和docker分不开，本文非要引入docker的原因也是因为他，他是一个为docker而设计的服务注册项目，他监听跨主机运行的容器的启动和停止，检查并向Consul注册。其实本文中其他的项目都可以单独在宿主机上运行，只是这个Registrator不行，所以最后的方案还是经过考虑再选择，毕竟学习docker也是需要一定的成本的。</p>
<p><strong>Nginx</strong>，这个软件就不用介绍了，大名鼎鼎，做静态文件服务器、反向代理、路由选择、负载均衡，支持极高并发，主流是nginx+tomcat?这个我不太清楚业界主流是Nginx加什么。多嘴一句，如果有兴趣阅读Nginx源码，要找到合适的方法，个人觉得还是彻底先了解功能后再进行源码阅读会比较好。</p>
<h1 id="u5927_u4F53_u601D_u8DEF"><a href="#u5927_u4F53_u601D_u8DEF" class="headerlink" title="大体思路"></a>大体思路</h1><p>1.启动Consul，Consul直接在宿主机上运行可以，在容器中运行也可以，看需求，本文后面的实际操作中，将Consul放到了Docker中。</p>
<p>2.Service A、Service B、Service C在启动时向Consul中注册自己，其他服务启动时也主动向Consul注册。</p>
<p>3.运行Consul template，正如概述中讲的，本文中template的作用就是更新Nginx配置文件并重启Nginx，我原本想这些组件都在Docker中运行，但是奈何我国国情，我真的pull不下来Consul template，所以就只能在宿主机上运行了。<strong>FUCK the GFW！</strong></p>
<p>4.Nginx，做负载均衡，要起得作用是动态的把网络消费者的请求转发到后台的Docker中。</p>
<p>大体流程图如下，配合着上述大体思路，我觉得应该能看懂了。<br><img src="http://7xr558.com1.z0.glb.clouddn.com/Service_Discovery.png" alt="Servive Discovery"></p>
<h1 id="u5B9E_u9645_u64CD_u4F5C"><a href="#u5B9E_u9645_u64CD_u4F5C" class="headerlink" title="实际操作"></a>实际操作</h1><p>实验环境：Ubuntu 14.04 <strong>64位</strong>，Docker官方强调64位了，也许你32的也能安上，但是pull下的很多东西不能用，比较蛋疼。</p>
<p>1.docker的安装和使用，自行Google或Bing。</p>
<p>2.构建一个web服务，此处参考</p>
<p>web服务器的Dockerfile如下：(注意：python3中好像是http.server)</p>
<pre><code>FROM python:2.7
EXPOSE 80
CMD [&quot;python&quot;,&quot;-m&quot;,&quot;SimpleHTTPServer&quot; ]
</code></pre><p>在Dockerfile所在的文件夹下执行,创建以个名为simplehttpserver的镜像</p>
<pre><code>docker build -t simplehttpserver .
</code></pre><p>利用上面创建的镜像构建容器：</p>
<pre><code>docker run -it -p 8000:80 simplehttpserver
</code></pre><p>即可通过浏览器或者<code>curl</code>访问。</p>
<p>3.docker中运行Consul（此处正式开始操作，第2步只是基础服务，要在系统跑起来之后再注册服务）</p>
<pre><code>docker run -it -h node -p 8500:8500 -p 8600:53/udp progrium/consul -server -bootstrap -advertise 127.0.0.1 -log-level debug
</code></pre><p>运行之后，Consul是自带UI界面的，所以通过浏览器可以访问。</p>
<p>4.docker中运行Registrator</p>
<pre><code>docker run -d --name=registratror --net=host --volume=/var/run/docker.sock:/tmp/docker.sock gliderlabs/registrator consul://127.0.0.1:8500
</code></pre><p>5.Host中运行Consul-template</p>
<pre><code>./consul-template -consul 127.0.0.1:8500 &quot;/etc/nginx/conf.d/test.ctmpl:/etc/nginx/config.d/test.conf:nginx -s reload&quot;
</code></pre><p>consul-template指定了模板的位置和生成文件的存放位置，然后对nginx进行重启就可以了。</p>
<p>上述步骤中各个模块的具体参数可以查看help。</p>
<h1 id="One_more_thing_u2026"><a href="#One_more_thing_u2026" class="headerlink" title="One more thing…"></a>One more thing…</h1><p>这个框架中的关键是Consul,这里用到了Consul的服务注册，个人感觉Consul服务注册有三种方法吧</p>
<p>A.通过编写配置文件(json)，指定配置文件的存放目录 –config-dir</p>
<p>B.通过Consul HTTP API，在实际程序中调用，当程序运行起来的时候自动注册</p>
<p>C.第三方注册，结合Docker使用，使用Registrator这样的工具</p>
<p>其中的优缺点想必大家也都了解了，通过A是要手动编写json配置文件并向Consul发送一个reload命令，我在想这样做好像不太合适，我们的目的是自动化的实现服务注册，在本文的应用场景下，与其重启Consul，还不如来个<code>nginx -s reload</code>,反正总有一个要重启嘛。B方案目前还没有实践，但可以想到也是会有问题的，在你程序里平白无辜加一段控制代码，谁都不愿意。C方案正是本文的实践方法，可以实现完全动态，但依赖于Docker平台和Registrator组件。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>写在最前面</strong>：本文尝试使用Docker、Registrator、Consul、Consul-template和Nginx实现可扩展的、支持服务注册、服务发现的架构。本文不涉及这些软件的具体实现方法，是对其功能进行探索。<br>]]>
    
    </summary>
    
      <category term="Service Discovery" scheme="http://lq08025107.github.io/tags/Service-Discovery/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sad]]></title>
    <link href="http://lq08025107.github.io/2016/03/19/Sad/"/>
    <id>http://lq08025107.github.io/2016/03/19/Sad/</id>
    <published>2016-03-19T14:38:10.000Z</published>
    <updated>2016-03-19T14:39:01.524Z</updated>
    <content type="html"><![CDATA[<p>以后再也见不到奶奶了。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以后再也见不到奶奶了。。。</p>
]]>
    </summary>
    
      <category term="生活" scheme="http://lq08025107.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[What is exactly RESRful programming]]></title>
    <link href="http://lq08025107.github.io/2016/03/09/What-is-exactly-RESRful-programming/"/>
    <id>http://lq08025107.github.io/2016/03/09/What-is-exactly-RESRful-programming/</id>
    <published>2016-03-09T14:19:44.000Z</published>
    <updated>2016-03-09T14:25:26.411Z</updated>
    <content type="html"><![CDATA[<p>相信大家在理解REST的时候挺困难吧，最近在理解的时候发现这么一个神贴，有助于理解REST。</p>
<p><strong>What is exactly RESRful programming</strong><br><a href="http://stackoverflow.com/questions/671118/what-exactly-is-restful-programming" target="_blank" rel="external">http://stackoverflow.com/questions/671118/what-exactly-is-restful-programming</a></p>
<p>REST和HTTP本来就相辅相成，一切用资源表述，外加几个动作，世界上万物和万物的吃喝拉撒就都解决了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>相信大家在理解REST的时候挺困难吧，最近在理解的时候发现这么一个神贴，有助于理解REST。</p>
<p><strong>What is exactly RESRful programming</strong><br><a href="http://stackoverfl]]>
    </summary>
    
      <category term="REST" scheme="http://lq08025107.github.io/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三月所感]]></title>
    <link href="http://lq08025107.github.io/2016/03/09/%E4%B8%89%E6%9C%88%E6%89%80%E6%84%9F/"/>
    <id>http://lq08025107.github.io/2016/03/09/三月所感/</id>
    <published>2016-03-09T11:51:37.000Z</published>
    <updated>2016-03-09T12:19:42.000Z</updated>
    <content type="html"><![CDATA[<p>这段日子比较忙，乱七八糟的事情，今天觉得还是瞎写写，有关生活的。</p>
<p>1.关于强行开博的问题。这个是我之前在知乎看到的一个问题，原帖内容是<strong>“你们周围有在github，博客上很活跃，但工作收入并不是很好的码农吗？”</strong>原帖链接如下：<br><a id="more"></a></p>
<p><a href="http://www.zhihu.com/question/32247845" title="你们周围有在github，博客上很活跃，但工作收入并不是很好的码农吗？" target="_blank" rel="external">http://www.zhihu.com/question/32247845</a></p>
<p>很多大神们都各抒己见，也有提到关于强行开博的问题，我就说说自己的感受，就拿我来说,</p>
<p>A.我之前也写的，我开博客，不一定完全是技术博，我这不也在写关于生活嘛，有时候记录一下生活感觉也是蛮好的。</p>
<p>B.博客的确很浪费时间。开了博客之后才注意到，写博客的确挺浪费时间的，前几篇本来脑子里还有点东西，可是那天写到了挺晚，然后舍友睡了，我这啪啦啪啦的敲键盘也不好，就匆匆结尾了。</p>
<p>C.博客的技术含量问题。这个其实是我最看重的问题，现在基本每个人都有个技术博，很多人写的都没什么技术含量，篇数倒是挺多，包括我自己在内，我的很多博客也是参考各种资料，技术含量基本为0，也只能给刚接触的人提供个参考。<strong>我的理解是：</strong>我完全拿博客当个日记了，复杂点的日记，记录自己学习的过程，也没期望有人看，别人看了我还会觉得会不会耽误人家的时间，所以也会尽量提高博客的含金量，尽力就好，毕竟这个社会冗余信息这么多，互联网上的信息也不在乎多我这么一点点，呵呵，有点无耻了。</p>
<p>2.前段时间忙着浏览各种J2EE和分布式技术，大约有JSP、Servlet、JavaBean、Struts2、Hibernate，RPC、Zookeeper，花了一俩周时间吧，的确了解到了不少，但是都没有深入，特别感谢<strong>王昊</strong>的指导，等再深入点、有时间的时候写一下，记录之。这俩天也算有点瓶颈了，还在努力突破，希望自己能在这条路上走的远一点吧，我还是对这些有些兴趣的。</p>
<p>3.今天<strong>户口</strong>下来了。我明白在帝都一个户口的重要性，也知道为了这个户口我所牺牲的东西，一步一步走到了今天，也不知道怎么形容了，不能说有悲，也不能说有喜，日子可能本身就这样吧。</p>
<p>今天就写这么多了，辅导一下二潇这个傻孩子。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这段日子比较忙，乱七八糟的事情，今天觉得还是瞎写写，有关生活的。</p>
<p>1.关于强行开博的问题。这个是我之前在知乎看到的一个问题，原帖内容是<strong>“你们周围有在github，博客上很活跃，但工作收入并不是很好的码农吗？”</strong>原帖链接如下：<br>]]>
    
    </summary>
    
      <category term="生活" scheme="http://lq08025107.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EasyDarwin入门实践]]></title>
    <link href="http://lq08025107.github.io/2016/03/06/EasyDarwin%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"/>
    <id>http://lq08025107.github.io/2016/03/06/EasyDarwin入门实践/</id>
    <published>2016-03-06T05:50:51.000Z</published>
    <updated>2016-03-06T05:54:01.729Z</updated>
    <content type="html"><![CDATA[<h1 id="EasyDarwin_u5F00_u6E90_u6D41_u5A92_u4F53_u5E73_u53F0"><a href="#EasyDarwin_u5F00_u6E90_u6D41_u5A92_u4F53_u5E73_u53F0" class="headerlink" title="EasyDarwin开源流媒体平台"></a>EasyDarwin开源流媒体平台</h1><p>本文大部分内容参考<br><a href="/EasyDarwin">http://doc.easydarwin.org/EasyDarwin/README/</a></p>
<p><strong>EasyDarwin</strong>是由国内开源流媒体团队开发和维护的一款开源流媒体平台框架，从2012年12月创建并发展至今，从原有的单服务的流媒体服务器形式，扩展成现在的云平台架构的开源项目，更好地帮助广大流媒体开发者和创业型企业快速构建流媒体服务平台，更快、更简单地实现最新的移动互联网(安卓、IOS、微信)流媒体直播与点播的需求，尤其是安防行业与互联网行业的衔接。<br><a id="more"></a></p>
<h1 id="EasyDawin_u76EE_u524D_u652F_u6301"><a href="#EasyDawin_u76EE_u524D_u652F_u6301" class="headerlink" title="EasyDawin目前支持"></a>EasyDawin目前支持</h1><p>1.MP4点播回放；</p>
<p>2.标准RTSP推模式直播(QTSSReflectorModule)；</p>
<p>3.标准RTSP拉模式直播(EasyRelayModule)；</p>
<p>4.HLS直播(EasyHLSModule)；</p>
<p>5.接入EasyDarwin流媒体平台，分布式部署；</p>
<h1 id="u7F16_u8BD1_u90E8_u7F72_u65B9_u6CD5"><a href="#u7F16_u8BD1_u90E8_u7F72_u65B9_u6CD5" class="headerlink" title="编译部署方法"></a>编译部署方法</h1><p>1.获取EasyDarwin最新版本。</p>
<p>2.VS下进行项目生成，将相关dll文件拷入文件夹中即可启动服务。</p>
<p>3.配置easydarwin.xml<br>主要的几个配置项：</p>
<p><strong>rtsp_port</strong>: EasyDarwin RTSP服务监听的端口；</p>
<p><strong>movie_folder</strong>:媒体文件存储的路径，包括点播文件、直播切片生成的hls文件；</p>
<p><strong>http_service_port</strong>:Webservice服务端口;</p>
<p><strong>hls_output_enabled</strong>：配置QTSSReflectorModule在接收推送的同时，是否同步输出hls；</p>
<p><strong>HTTP_ROOT_DIR</strong>：配置EasyHLSModule的对外WEB路径；</p>
<p><strong>local_ip_address</strong>：配置EasyRelayModule对外服务的ip地址，因为可能会有多网卡或者内网映射，所以需要手动配置；</p>
<p>4.运行EasyDarwin</p>
<p>【前提】EasyDarwin可执行文件必须与/html/目录在同一层目录中</p>
<p>Windows版本运行(控制台调试运行)：</p>
<pre><code>EasyDarwin.exe -c ./easydarwin.xml -d
</code></pre><p>注：需要把libEasyHLS.dll，libEasyPusher.dll，libEasyRTSPClient.dll，html文件夹和Movies文件夹拷贝到可执行程序的同目录下！</p>
<p>Windows服务运行：</p>
<pre><code>cd ./
set curPath=&quot;%cd%&quot;
echo service path：%curPath%
sc create EasyDarwin binPath= &quot;%curPath%\EasyDarwin.exe -c %curPath%\easydarwin.xml&quot; start= auto
sc failure EasyDarwin reset= 0 actions= restart/0
net start EasyDarwin
pause
</code></pre><p>将这段脚本做成bat，运行，我们就创建了一个叫做EasyDarwin的Windows服务了，通过系统服务（services.msc）可以查看到。 注：Windows不同版本可能稍有差异，建议在命令行运行bat脚本，而不是直接双击运行，这样能看到具体出错原因！</p>
<p>5.具体使用示例</p>
<p>MP4点播</p>
<p>将经过Hint处理过的mp4文件存在movie_folder目录中，访问RTSP地址：</p>
<pre><code>rtsp:://[ip]:[rtsp_port]/[filename]
</code></pre><p>使用VLC等播放器即可播放。</p>
<p>推模式转发</p>
<p>直接通过标准RTSP/RTP推送流程（ANNOUNCE/SETUP/PLAY/RTP）向EasyDarwin推送音视频数据进行转发和分发，例如rtsp_port配置为8554，那我们可以直接用EasyDarwin EasyPusher或者live555 DarwinInjector向8554端口进行直播推送；</p>
<p>拉模式转发</p>
<p>调用接口（用vlc、ffplay、live555等RTSP Client调用）</p>
<pre><code>RTSP://[ip]:[rtsp_port]/EasyRelayModule?name=[relayName]&amp;url=&quot;[RTSP_URL]&quot;
</code></pre><p>例如EasyDarwin服务器IP地址是：8.8.8.8，RTSP端口(rtsp_port)：554，IPCamera的RTSP地址是：rtsp://admin:admin@192.168.66.189/22，那么我们可以：</p>
<p>1、配置easydarwin.xml EasyRelayModule</p>
<pre><code>&lt;PREF NAME=&quot;local_ip_address&quot; &gt;8.8.8.8&lt;/PREF&gt;
</code></pre><p>2、请求转发：RTSP://8.8.8.8:554/EasyRelayModule?name=live&amp;url=”rtsp://admin:admin@192.168.66.189/22” （name是定义一个拉模式转发流的唯一标识，不允许重复）</p>
<p>3、直播URL：RTSP://8.8.8.8:554/EasyRelayModule?name=live</p>
<p>4、请求停止转发：RTSP://8.8.8.8:554/EasyRelayModule?name=live&amp;cmd=stop （cmd=stop表示停止拉模式转发）</p>
<p>6.实际操作</p>
<p>A 使用EasyDarwin+VLC进行MP4点播，效果如下：<br><img src="http://7xr558.com1.z0.glb.clouddn.com/easydarwinmp4.png" alt="MP4点播"></p>
<p>B 使用EasyPuhser+EasyDarwin+Nginx查看网页直播<br>具体操作详见最上面网址，配置过程一定要知道每一步自己在干什么，配合Nginx+EasyPusher+EasyDarwin，可以实现向服务器推送RTSP流，然后转发到公网进行查看。效果如下：<br><img src="http://7xr558.com1.z0.glb.clouddn.com/HLS.png" alt="HLS"></p>
<p>7.这一套每个工具的作用<br>EasyDarwin：直播、点播，安防行业与互联网行业对接</p>
<pre><code>输入：MP4本地文件 RTSP流
输出：RTSP流 HLS直播
</code></pre><p>EasyPusher：一个给EasyDarwin推送流媒体音视频的推送库，使EasyDarwin可以进行转发和分发</p>
<pre><code>EasyPush_FILE：推送本地文件到服务器
EasyPusher_RTSP：通过EasyRTSPClient库，将RTSP/RTP数据获取到本地，再推送到EasyDarwin
支持的视频编码有：H264、MJPEG、MPEG4
支持的音频编码有：AAC、G711 alaw、G711 ulaw
</code></pre><p>EasyHLS：只需要传入打包的文件名、切片存放的目录、单个切片时长以及切片数等参数，EasyHLS库就能轻松将H264+AAC的流媒体切片成m3u8+ts，提供给WEB服务器进行HLS流媒体发布；</p>
<pre><code>EasyHLS_RTSP：通过RTSPClient将RTSP URL的流媒体数据获取并进行ts打包，提供HLS直播
</code></pre><p>EasyRTSPClient：EasyRTSPClient是EasyDarwin开源流媒体团队提供的一套非常稳定、易用、支持重连的RTSPClient工具，接口调用非常简单，再也不用像调用live555那样处理整个RTSP OPTIONS/DESCRIBE/SETUP/PLAY的复杂流程，担心内存释放的问题了！</p>
<pre><code>拉取RTSP流到本地
</code></pre><p>EasyClient：客户端项目，支持多种源接入，Windows摄像头、麦克风、RTSP摄像机、屏幕桌面，采集后经过264编码、EasyPuhser推送到流媒体服务器进行转发；还支持通过EasyRTSPClient拉取EasyDarwin直播流，充当VLC的作用。如下图所示：</p>
<p><img src="http://7xr558.com1.z0.glb.clouddn.com/EasyClient.png" alt="Client"></p>
<p>总之，这一套解决方案算是全的了，有如下这些（官网截图，我们用的只是其中一小部分）：</p>
<p><img src="http://7xr558.com1.z0.glb.clouddn.com/EasyDarwin%E7%B3%BB%E5%88%97%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="系列解决方案"></p>
<p>8.科普小知识</p>
<p>HLS(HTTP Living Streaming):Apple的动态码率自适应技术。主要用于PC和Apple终端的音视频服务。包括一个m3u(8)的索引文件，TS媒体分片文件和key加密串文件。</p>
<p>RTSP(Real Time Streaming Protocol):实时流传输协议，用于在客户端和服务器之间建立和协商实时流会话。</p>
<p>有兴趣的可以多研究研究。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="EasyDarwin_u5F00_u6E90_u6D41_u5A92_u4F53_u5E73_u53F0"><a href="#EasyDarwin_u5F00_u6E90_u6D41_u5A92_u4F53_u5E73_u53F0" class="headerlink" title="EasyDarwin开源流媒体平台"></a>EasyDarwin开源流媒体平台</h1><p>本文大部分内容参考<br><a href="/EasyDarwin">http://doc.easydarwin.org/EasyDarwin/README/</a></p>
<p><strong>EasyDarwin</strong>是由国内开源流媒体团队开发和维护的一款开源流媒体平台框架，从2012年12月创建并发展至今，从原有的单服务的流媒体服务器形式，扩展成现在的云平台架构的开源项目，更好地帮助广大流媒体开发者和创业型企业快速构建流媒体服务平台，更快、更简单地实现最新的移动互联网(安卓、IOS、微信)流媒体直播与点播的需求，尤其是安防行业与互联网行业的衔接。<br>]]>
    
    </summary>
    
      <category term="EasyDarwin" scheme="http://lq08025107.github.io/tags/EasyDarwin/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop之HDFS]]></title>
    <link href="http://lq08025107.github.io/2016/02/29/Hadoop%E4%B9%8BHDFS/"/>
    <id>http://lq08025107.github.io/2016/02/29/Hadoop之HDFS/</id>
    <published>2016-02-29T12:14:01.000Z</published>
    <updated>2016-02-29T14:21:31.472Z</updated>
    <content type="html"><![CDATA[<p>Hadoop是Apache基金会研发的分布式系统基础架构，具体项目来源、发展历程随便上网查一查，一堆一堆的。不知道大家注意到没，市面上Hadoop书籍上面都是一只小象，据说是作者儿子的一个毛绒玩具，小孩子的创造力总是无穷的，才能有这么好听的名字，哈哈，开始，其实我研究的并不深，先是停留在原理性和了解性的阶段，并没有涉及代码层次。</p>
<p>Hadoop的中心思想是利用普通硬件组成集群，来替代性能高、价钱高的服务器，当然到了一个极限的话，价格再高也换不来高性能了，所以Hadoop<br>的出现很有必要。Hadoop主要是要解决两个方面的问题：<strong>存储</strong>、<strong>运算</strong>。这篇文章主要是讲存储系统，即HDFS。<br><a id="more"></a></p>
<p>HDFS(Hadoop Distribute File System，Hadoop分布式文件系统)1.首先是运行在廉价的服务器上 2.需要保存多个副本（默认3个副本），提供容错机制，副本丢失会自动恢复 3.HDFS将文件分割成block，默认大小是64M，然后将block按键值对存储在内存中，若block划分太小，小文件太多的话，内存开销太大，所以HDFS适合处理大数据。</p>
<p>先给出一幅图，然后对图中进行解释：<br><img src="http://7xr558.com1.z0.glb.clouddn.com/hdfs.png" alt="HDFS"></p>
<p>NameNode：名字节点，位于HDFS主端，指导从端的DataNode执行底层的I/O任务，是HDFS中最关键的一点，跟踪文件如何被分割成文件块，文件块被存储在哪些DataNode中等信息，监测整体运行是否正常。</p>
<p>DataNode：数据节点，存储数据，执行MapReduce运算(这个不属于HDFS范畴，不细说)</p>
<p>Secondary NameNode：不接收或记录HDFS的任何实时变化，仅与NameNode通信，按照时间间隔获取快照。</p>
<p>HDFS终究也是个文件系统，文件系统最主要还是离不开读写，无论底层怎么复杂，对用户都是透明的，我们可以大体看一下HDFS读文件的流程。<br><img src="http://7xr558.com1.z0.glb.clouddn.com/HDFS%20%E8%AF%BB%E6%96%87%E4%BB%B6.png" alt="HDFS读文件"></p>
<p>HDFS写文件，以创建新文件并保存为例。<br><img src="http://7xr558.com1.z0.glb.clouddn.com/HDFS%E6%96%B0%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%B9%B6%E4%BF%9D%E5%AD%98.png" alt="HDFS保存"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Hadoop是Apache基金会研发的分布式系统基础架构，具体项目来源、发展历程随便上网查一查，一堆一堆的。不知道大家注意到没，市面上Hadoop书籍上面都是一只小象，据说是作者儿子的一个毛绒玩具，小孩子的创造力总是无穷的，才能有这么好听的名字，哈哈，开始，其实我研究的并不深，先是停留在原理性和了解性的阶段，并没有涉及代码层次。</p>
<p>Hadoop的中心思想是利用普通硬件组成集群，来替代性能高、价钱高的服务器，当然到了一个极限的话，价格再高也换不来高性能了，所以Hadoop<br>的出现很有必要。Hadoop主要是要解决两个方面的问题：<strong>存储</strong>、<strong>运算</strong>。这篇文章主要是讲存储系统，即HDFS。<br>]]>
    
    </summary>
    
      <category term="Hadoop HDFS" scheme="http://lq08025107.github.io/tags/Hadoop-HDFS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RPC(Remote Procedure Call Protocol)]]></title>
    <link href="http://lq08025107.github.io/2016/02/24/RPC-Remote-Procedure-Call-Protocol/"/>
    <id>http://lq08025107.github.io/2016/02/24/RPC-Remote-Procedure-Call-Protocol/</id>
    <published>2016-02-24T14:19:56.000Z</published>
    <updated>2016-03-06T05:52:31.200Z</updated>
    <content type="html"><![CDATA[<h1 id="1-_u5B9A_u4E49"><a href="#1-_u5B9A_u4E49" class="headerlink" title="1.定义"></a>1.定义</h1><p>RPC:Remote Procedure Call protocol,远程过程调用协议，通俗来讲即两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>
<h1 id="2-_u8981_u89E3_u51B3_u7684_u95EE_u9898"><a href="#2-_u8981_u89E3_u51B3_u7684_u95EE_u9898" class="headerlink" title="2.要解决的问题"></a>2.要解决的问题</h1><p>正如定义所述，RPC从本质上来讲，只是一种网络通信，由于互联网的高速发展，同一台机器之间需要进行进程之间的通信，然后不同机器之间的进程也需要通信，RPC要解决的问题就是这个，RPC是分布式、集群的基础吧。<br><a id="more"></a></p>
<h1 id="3-_u5982_u4F55_u5B9E_u73B0"><a href="#3-_u5982_u4F55_u5B9E_u73B0" class="headerlink" title="3.如何实现"></a>3.如何实现</h1><p>引用如下的图，来说明RPC的实现原理<br><img src="http://7xr558.com1.z0.glb.clouddn.com/45366c44f775abfd0ac3b43bccc1abc3_r.jpg" alt="PicMissing"><br>从分层的角度来看，个人觉得RPC涉及到了应用层和传输层，这个图例一眼就能看懂，无需多言，如果要自己实现一个这样的框架，应该考虑哪些问题呢？</p>
<p>(A)在Server和Client之间建立TCP通信连接，可以是按需连接，也可以是长连接。</p>
<p>(B)Client如何找到Server，既然是通信，总需要一些向IP、Port之类的东西，还有与Server端的哪个进程的哪个方法通信等问题。</p>
<p>(C)方法的参数传递方式，Client需要把所谓的实参通过网络传递给Server端，就要涉及将内存中的值序列化成二进制的值。</p>
<p>(D)Server收到后需要进行反序列化，然后进行本地调用，得到返回值。</p>
<p>(E)Server将返回值序列化成二进制序列传输给Client，Client进行反序列化即可。</p>
<h1 id="4-_u6846_u67B6"><a href="#4-_u6846_u67B6" class="headerlink" title="4.框架"></a>4.框架</h1><p>RPC只是一个概念，当然有很多组织和企业用自己的方法实现，实现出来的结果就是所谓的框架，搜索了一下，主要有CORBA(Common Object Request Broker Architecture,通用对象请求代理体系结构)、JAVA RMI(Remote Method Invocation,远程方法调用)和Thrift(FB开源框架)等等。</p>
<h1 id="5-_u5B9E_u73B0"><a href="#5-_u5B9E_u73B0" class="headerlink" title="5.实现"></a>5.实现</h1><p>在4.框架中提到了Java的RPC，即RMI，由于我也是Java新手，所以就大体找了个HelloWorld试了试，转自<a href="http://lavasoft.blog.51cto.com/62575/91679/" target="_blank" rel="external">熔岩</a>,代码如下：<br>首先定义接口：IHello<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> <span class="keyword">extends</span> <span class="title">Remote</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHelloToSomeBody</span><span class="params">(String someBodyName)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是服务器端的实现HelloImpl<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IHello</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HelloImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HelloWorld!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHelloToSomeBody</span><span class="params">(String someBodyName)</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello "</span>+someBodyName+<span class="string">"!"</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是服务器端的HelloServer<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming; </span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			IHello rhello=<span class="keyword">new</span> HelloImpl();</span><br><span class="line">			LocateRegistry.createRegistry(<span class="number">8888</span>);</span><br><span class="line">			Naming.bind(<span class="string">"rmi://localhost:8888/RHello"</span>,rhello);</span><br><span class="line">			System.out.println(<span class="string">"INFO:Bingding Remote Object IHello Successfully!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(RemoteException e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"Creating Remote Object Exception"</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">catch</span>(AlreadyBoundException e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"AlreadyBoundException"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(MalformedURLException e)&#123;</span><br><span class="line">			System.out.println(<span class="string">"MalformedURLException"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此可以运行起来Server端，就不上图了，很简单。</p>
<p>最后是客户端的HelloClient<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming; </span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			IHello rhello=(IHello)Naming.lookup(<span class="string">"rmi://localhost:8888/RHello"</span>);</span><br><span class="line">			System.out.println(rhello.helloWorld());</span><br><span class="line">			System.out.println(rhello.sayHelloToSomeBody(<span class="string">"LiuQiang"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(NotBoundException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(MalformedURLException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(RemoteException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后上一张图：<br><img src="http://7xr558.com1.z0.glb.clouddn.com/RMIClient.png" alt="PicMissing"><br>打算如果有时间，试试facebook的RPC：Thrift。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-_u5B9A_u4E49"><a href="#1-_u5B9A_u4E49" class="headerlink" title="1.定义"></a>1.定义</h1><p>RPC:Remote Procedure Call protocol,远程过程调用协议，通俗来讲即两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>
<h1 id="2-_u8981_u89E3_u51B3_u7684_u95EE_u9898"><a href="#2-_u8981_u89E3_u51B3_u7684_u95EE_u9898" class="headerlink" title="2.要解决的问题"></a>2.要解决的问题</h1><p>正如定义所述，RPC从本质上来讲，只是一种网络通信，由于互联网的高速发展，同一台机器之间需要进行进程之间的通信，然后不同机器之间的进程也需要通信，RPC要解决的问题就是这个，RPC是分布式、集群的基础吧。<br>]]>
    
    </summary>
    
      <category term="RPC Java" scheme="http://lq08025107.github.io/tags/RPC-Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://lq08025107.github.io/2016/02/22/Hello-World/"/>
    <id>http://lq08025107.github.io/2016/02/22/Hello-World/</id>
    <published>2016-02-22T13:31:57.000Z</published>
    <updated>2016-03-06T05:52:06.499Z</updated>
    <content type="html"><![CDATA[<p>这是我使用Github+Hexo的第一篇博客，也不管到底是技术博还是生活或者情感博了，也不知道以后会不会继续更新了，但至少我知道有一个地方，在无聊的时候我可以进来发泄一下。</p>
<p>今天是正月十五，元宵节，这个节日在我家乡那边算一个很隆重的节日了，刚才爸爸和姐姐去溜大街了，想想自己好久没在家过元宵节了。还记得很小很小的时候，我们还在村里住着，元宵节我和姐姐到城里外婆家过十五，两个人可能一共有1块钱，我姐掌管着（小时候我很依靠姐姐），然后走到烤羊肉串旁边，我说：姐姐，我想吃羊肉串。我俩都不知道那到底是什么味道，后来，姐姐花了2毛钱给我买了一串，具体什么味道早已经忘记了，可是这个细节我记了很久很久。<br><a id="more"></a></p>
<p>上传几张照片，今天突然很想姐姐。<br><img src="http://7xr558.com1.z0.glb.clouddn.com/DSC05428.JPG" alt="PicMissing"><br>这张是我大三时候姐姐去天津找我玩</p>
<p><img src="http://7xr558.com1.z0.glb.clouddn.com/DSC05418.JPG" alt="PicMissing"><br>嘿嘿，我姐漂亮吧</p>
<p>前几天姐来北京拍了婚纱照了，time fly，很怀念小的时候，愿我们都好！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是我使用Github+Hexo的第一篇博客，也不管到底是技术博还是生活或者情感博了，也不知道以后会不会继续更新了，但至少我知道有一个地方，在无聊的时候我可以进来发泄一下。</p>
<p>今天是正月十五，元宵节，这个节日在我家乡那边算一个很隆重的节日了，刚才爸爸和姐姐去溜大街了，想想自己好久没在家过元宵节了。还记得很小很小的时候，我们还在村里住着，元宵节我和姐姐到城里外婆家过十五，两个人可能一共有1块钱，我姐掌管着（小时候我很依靠姐姐），然后走到烤羊肉串旁边，我说：姐姐，我想吃羊肉串。我俩都不知道那到底是什么味道，后来，姐姐花了2毛钱给我买了一串，具体什么味道早已经忘记了，可是这个细节我记了很久很久。<br>]]>
    
    </summary>
    
      <category term="生活" scheme="http://lq08025107.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://lq08025107.github.io/2016/02/22/11/"/>
    <id>http://lq08025107.github.io/2016/02/22/11/</id>
    <published>2016-02-22T13:31:57.000Z</published>
    <updated>2016-04-19T14:24:15.267Z</updated>
    <content type="html"><![CDATA[<p>11</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>11</p>
]]>
    </summary>
    
      <category term="生活" scheme="http://lq08025107.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
